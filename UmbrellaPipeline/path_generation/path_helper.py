import os
from typing import List

import openmm as mm
import openmm.app as app
import openmm.unit as unit
from openmm import Vec3

aa_list = [
    "ala",
    "arg",
    "asn",
    "asp",
    "cys",
    "gln",
    "glu",
    "gly",
    "his",
    "ile",
    "leu",
    "lys",
    "met",
    "phe",
    "pro",
    "pyl",
    "ser",
    "sec",
    "thr",
    "trp",
    "tyr",
    "val",
    "asx",
    "glx",
    "xaa",
    "xle",
]


def get_residue_indices(
    atom_list: app.internal.charmm.topologyobjects.AtomList,
    name: List[str] or str = aa_list,
    include_hydrogens: bool = True,
) -> List[int]:
    """
    Returns a list of indices that correspond to a given residue in the pdb file.

    Args:
        atom_list (app.internal.charmm.topologyobjects.AtomList): atom list that should be searched.
        name (List[str]orstr, optional): residue name. if none is given, the atom list is searched for amino acid residues. Defaults to aa_list.

    Returns:
        List[int]: list of indices in the pdb file.
    """
    ret = []
    for i, atom in enumerate(atom_list):
        if isinstance(name, str):
            if not include_hydrogens and "[H" in str(atom):
                continue
            if name.lower() in str(atom).lower():
                ret.append(i)
        else:
            if not include_hydrogens and "[H" in str(atom):
                continue
            if any(aa.lower() in str(atom).lower() for aa in name):
                ret.append(i)
    return ret


def get_centroid_coordinates(
    positions: unit.Quantity,
    indices: List[int],
) -> unit.Quantity:
    """
    Calculates centroid coordinates of a given number of atoms or molecules.

    Args:
        positions (unit.Quantity): positions of all atoms in the system
        indices (List[int]): indices of the atoms you want the centroid from.

    Returns:
        unit.Quantity: Centroid coordinates of the specified atoms
    """
    try:
        ret = [0 * positions.unit, 0 * positions.unit, 0 * positions.unit]
        for coordinate in range(3):
            for i in indices:
                ret[coordinate] += positions[i][coordinate]
            ret[coordinate] /= len(indices) * positions.unit
        return unit.Quantity(
            value=Vec3(x=ret[0], y=ret[1], z=ret[2]), unit=positions.unit
        )
    except AttributeError:
        ret = [0, 0, 0]
        for coordinates in range(3):
            for i in indices:
                ret[coordinates] += positions[i][coordinates]
            ret[coordinates] /= len(indices)
        return ret


def get_center_of_mass_coordinates(
    positions: unit.Quantity,
    indices: unit.Quantity,
    masses: mm.openmm.System,
    include_hydrogens: bool = True,
) -> unit.Quantity:
    """
    Calculates center of mass coordinates of a given number of atoms or molecules.

    Args:
        positions (unit.Quantity): positions of all atoms in the system
        indices (List[int]): indices of the atoms you want the centroid from.
        masses (mm.openmm.System): openmm System that contains all the atom masses.

    Returns:
        unit.Quantity: center of mass coordinates of the specified atoms
    """
    try:
        ret = [0 * unit.dalton, 0 * unit.dalton, 0 * unit.dalton]
        mass = 0 * unit.dalton
        for coordinate in range(3):
            for atomnr in indices:
                if (
                    not include_hydrogens
                    and masses.getParticleMass(atomnr) < 1.2 * unit.dalton
                ):
                    continue
                ret[coordinate] += positions[atomnr][coordinate].value_in_unit(
                    positions.unit
                ) * masses.getParticleMass(atomnr)
                mass += masses.getParticleMass(atomnr)
            ret[coordinate] /= mass
        return unit.Quantity(
            value=Vec3(x=ret[0], y=ret[1], z=ret[2]), unit=positions.unit
        )
    except AttributeError:
        ret = [0 * unit.angstroms, 0 * unit.angstroms, 0 * unit.angstroms]
        for coordinate in range(len(ret)):
            c = 0.0
            m = 0.0
            for atomnr in indices[0:2]:
                c += (
                    positions[int(atomnr)][int(coordinate)]
                    * masses.getParticleMass(atomnr)
                    / unit.dalton
                )
                m += masses.getParticleMass(atomnr) / unit.dalton
            ret[coordinate] = c / m
        return unit.Quantity(
            value=Vec3(x=ret[0], y=ret[1], z=ret[2]), unit=unit.nanometer
        )


def parse_params(
    toppar_directory: str, toppar_str_file: str
) -> app.charmmparameterset.CharmmParameterSet:
    """
    use to read in top and par files generated by the charmm-gui. IMPORTANT: allways give the path to the openmm (created by charmm gui) folder within the charmm-gui folder.
    addapted from charmgui omm_readparams.py
    Args:
        param_directory (str): folder created by charmm_gui

    Returns:
        app.charmmparameterset.CharmmParameterSet: [description]
    """
    if not toppar_str_file.startswith("/"):
        now = os.getcwd()
        toppar_str_file = now + "/" + toppar_str_file
    current_dir = os.getcwd()
    os.chdir(toppar_directory)
    parFiles = ()
    for line in open(toppar_str_file, "r"):
        if "!" in line:
            line = line.split("!")[0]
        parfile = line.strip()
        if len(parfile) != 0:
            parFiles += (parfile,)
    ret = app.CharmmParameterSet(*parFiles)
    os.chdir(current_dir)
    return ret


def gen_pbc_box(
    psf: str or app.CharmmPsfFile,
    pdb: str or app.PDBFile,
) -> List[unit.Quantity]:
    """
    Adapted from charmm_gui readparams. Generates pbc box and adds it to the psf. returns offset of the box from 0,0,0.

    Args:
        psf (strorapp.CharmmPsfFile): psf file or path to psf file
        pdb (strorapp.PDBFile): pdb file or path to pdb file

    Returns:
        List[unit.Quantity]: offset of box from 0,0,0
    """
    if type(pdb) is str:
        pdb = app.PDBFile(pdb)
    if type(psf) is str:
        psf = app.CharmmPsfFile(psf)
    coords = pdb.positions

    min_crds = [coords[0][0], coords[0][1], coords[0][2]]
    max_crds = [coords[0][0], coords[0][1], coords[0][2]]

    for coord in coords:
        min_crds[0] = min(min_crds[0], coord[0])
        min_crds[1] = min(min_crds[1], coord[1])
        min_crds[2] = min(min_crds[2], coord[2])
        max_crds[0] = max(max_crds[0], coord[0])
        max_crds[1] = max(max_crds[1], coord[1])
        max_crds[2] = max(max_crds[2], coord[2])

    boxlx = max_crds[0] - min_crds[0]
    boxly = max_crds[1] - min_crds[1]
    boxlz = max_crds[2] - min_crds[2]

    psf.setBox(boxlx, boxly, boxlz)
    return min_crds
