import os, time, logging
import openmm as mm
import openmmtools
from openmm import app, unit
from typing import List, Tuple

from UmbrellaPipeline.sampling import (
    update_restraint,
    serialize_system,
    serialize_state,
    extract_nonbonded_parameters,
    write_path_to_file,
    create_openmm_system,
)
from UmbrellaPipeline.utils import (
    display_time,
    SimulationParameters,
    SystemInfo,
    gen_pbc_box,
)

try:
    from typing import Literal
except:
    from typing_extensions import Literal

logger = logging.getLogger(__name__)


class UmbrellaSampling:

    def __init__(
        self,
        simulation_parameters: SimulationParameters,
        system_info: SystemInfo,
        traj_write_path: str = os.getcwd(),
        restrain_protein_backbone: bool = False,
    ) -> None:
        """
        This clases is used to run the umbrella Sampling on your Local computer. It contains two methods to run your equilibration and your
        production runs separately.

        Args:
            simulation_parameters (SimulationParameters): simulation simulation_parameter object, holding temp, pressure, etc
            system_info (SystemInfo): simulation system object holding psf, crd objects etc.
            path (List[unit.Quantity]): path for the umbrella sampling to run along.
            traj_write_path (str, optional): output directory where the trajectories are written to. Defaults to os.getcwd().
            restrain_protein_backbone (bool, optional): wheter te protein backbone should be restrained during the simulations or not. Defaults to False.
        """
        self.simulation_parameters = simulation_parameters
        self.system_info = system_info
        self.openmm_system: mm.openmm.System
        self.simulation: app.Simulation
        self.integrator: mm.openmm.Integrator
        self.bb_restrains = restrain_protein_backbone

        self.platform = openmmtools.utils.get_fastest_platform()
        if self.platform.getName() == ("CUDA" or "OpenCL"):
            self.platformProperties = {"Precision": "mixed"}
        else:
            self.platformProperties = None

        self.traj_write_path = traj_write_path
        self.traj_write_path = os.path.abspath(self.traj_write_path.rstrip("/"))
        self.ligand_non_bonded_parameters = []

    def run_equilibration(
        self,
        use_membrane_barostat: bool = False,
        nonbonded_method: app.forcefield = app.PME,
        nonbonded_cutoff: unit.Quantity = 1.2 * unit.nanometer,
        switch_distance: unit.Quantity = 1 * unit.nanometer,
        rigid_water: bool = True,
        constraints: app.forcefield = app.HBonds,
    ) -> mm.State:
        """
        This runs an equilbration in the NPT ensemble. Encouraged to run if you use this tool together with input generated by the charmm-gui directly.

        Args:
            use_membrane_barostat (bool, optional): Wheter to use a membrane or an isotropic barostat. False means you are deploying the isotropic barostat. Defaults to False.
            nonbonded_method (app.forcefield, optional): which nonbonded method to use. Specify as an openmm.app object. Defaults to app.PME.
            nonbonded_cutoff (unit.Quantity, optional): which nonbonded cutoff to use. Defaults to 1.2*unit.nanometer.
            switch_distance (unit.Quantity, optional): Switch distance for the nonbonded cutoff. Defaults to 1*unit.nanometer.
            rigid_water (bool, optional): Wheter to use rigid water in the simulation. Defaults to True.
            constraints (app.forcefield, optional): Constraints you want to use in the Simulation. Defaults to app.HBonds.

        Returns:
            mm.State: Returns the state object of the simulations after the equilibration period.
        """
        if use_membrane_barostat:
            baro = "membrane"
        else:
            baro = "isotropic"
        if not self.system_info.psf_object.boxLengths:
            gen_pbc_box(
                psf=self.system_info.psf_object,
                pos=self.system_info.crd_object.positions,
            )
        self.openmm_system = create_openmm_system(
            system_info=self.system_info,
            simulation_parameters=self.simulation_parameters,
            barostat=baro,
            nonbonded_cutoff=nonbonded_cutoff,
            nonbonded_method=nonbonded_method,
            switch_distance=switch_distance,
            constraints=constraints,
            rigid_water=rigid_water,
        )

        self.integrator = mm.LangevinIntegrator(
            self.simulation_parameters.temperature,
            self.simulation_parameters.friction_coefficient,
            self.simulation_parameters.time_step,
        )

        self.simulation = app.Simulation(
            topology=self.system_info.psf_object.topology,
            system=self.openmm_system,
            integrator=self.integrator,
            platform=self.platform,
            platformProperties=self.platformProperties,
        )

        self.simulation.context.setPositions(self.system_info.crd_object.positions)
        self.simulation.minimizeEnergy()
        self.simulation.context.setVelocitiesToTemperature(
            self.simulation_parameters.temperature
        )
        self.simulation.reporters.append(
            app.DCDReporter(
                file=f"{self.traj_write_path}/equilibration_trajectory.dcd",
                reportInterval=self.simulation_parameters.write_out_frequency,
            )
        )
        self.simulation.reporters.append(
            app.StateDataReporter(
                file=f"{self.traj_write_path}/equilibration_state.out",
                reportInterval=self.simulation_parameters.write_out_frequency,
                step=True,
                time=True,
                potentialEnergy=True,
                totalEnergy=True,
                temperature=True,
                volume=True,
            )
        )
        st = time.time()
        logger.info("Equilibration started.")
        self.simulation.step(self.simulation_parameters.n_equilibration_steps)
        et = time.time() - st
        logger.info(f"Equilibration finished. Elapsed time: {display_time(et)}")
        state = self.simulation.context.getState(getPositions=True, getVelocities=True)
        return state

    def run_production(
        self,
        path: unit.Quantity,
        state: mm.State,
        nonbonded_method: app.forcefield = app.PME,
        nonbonded_cutoff: unit.Quantity = 1.2 * unit.nanometer,
        switch_distance: unit.Quantity = 1 * unit.nanometer,
        rigid_water: bool = True,
        constraints: app.forcefield = app.HBonds,
    ):
        """
        This function runs the umbrella sampling itself. 

        Args:
            path (unit.Quantity): Path generated along wich the Umbrella Sampling is Conducted.
            state (mm.State): State retrieved from the Equilibration. 
            nonbonded_method (app.forcefield, optional): which nonbonded method to use. Specify as an openmm.app object. Defaults to app.PME.
            nonbonded_cutoff (unit.Quantity, optional): which nonbonded cutoff to use. Defaults to 1.2*unit.nanometer.
            switch_distance (unit.Quantity, optional): Switch distance for the nonbonded cutoff. Defaults to 1*unit.nanometer.
            rigid_water (bool, optional): Wheter to use rigid water in the simulation. Defaults to True.
            constraints (app.forcefield, optional): Constraints you want to use in the Simulation. Defaults to app.HBonds.
        """

        if not self.system_info.psf_object.boxLengths:
            gen_pbc_box(
                psf=self.system_info.psf_object,
                pos=self.system_info.crd_object.positions,
            )
        self.openmm_system = create_openmm_system(
            system_info=self.system_info,
            simulation_parameters=self.simulation_parameters,
            ligand_restraint=True,
            path=path,
            bb_restraints=self.bb_restrains,
            nonbonded_cutoff=nonbonded_cutoff,
            nonbonded_method=nonbonded_method,
            switch_distance=switch_distance,
            constraints=constraints,
            rigid_water=rigid_water,
            positions=state.getPositions(),
        )

        self.integrator = mm.LangevinIntegrator(
            self.simulation_parameters.temperature,
            self.simulation_parameters.friction_coefficient,
            self.simulation_parameters.time_step,
        )

        self.simulation = app.Simulation(
            topology=self.system_info.psf_object.topology,
            system=self.openmm_system,
            integrator=self.integrator,
            platform=self.platform,
            platformProperties=self.platformProperties,
        )

        self.simulation.context.setState(state=state)
        self.simulation.minimizeEnergy()
        self.simulation.step(self.simulation_parameters.n_equilibration_steps)

        self.ligand_non_bonded_parameters = extract_nonbonded_parameters(
            self.openmm_system, self.system_info.ligand_indices
        )
        total_time = 0
        for window, position in enumerate(path):
            start_time = time.time()
            self.simulation.reporters.append(
                app.DCDReporter(
                    file=f"{self.traj_write_path}/production_trajectory_window_{window}.dcd",
                    reportInterval=self.simulation_parameters.write_out_frequency,
                )
            )
            self.simulation.reporters.append(
                app.StateDataReporter(
                    file=f"{self.traj_write_path}/production_state_window_{window}.out",
                    reportInterval=self.simulation_parameters.write_out_frequency,
                    step=True,
                    time=True,
                    potentialEnergy=True,
                    totalEnergy=True,
                    temperature=True,
                    volume=True,
                )
            )

            self.simulation.step(self.simulation_parameters.n_production_steps)

            elapsed_time = time.time() - start_time
            total_time += elapsed_time
            logger.info(
                f"Window {window+1} of {len(path)} simulated. "
                f"Elapsed Time: {display_time(elapsed_time)}. "
                f"Elapsed total time: {display_time(total_time)}. "
                f"Estimated time until finish: {display_time((len(path) - window + 1) * elapsed_time) }."
            )

            self.simulation.reporters.clear()
            try:
                update_restraint(
                    simulation=self.simulation,
                    ligand_indices=self.system_info.ligand_indices,
                    original_parameters=self.ligand_non_bonded_parameters,
                    position=position,
                )
                self.simulation.step(self.simulation_parameters.n_equilibration_steps)
            except IndexError:
                pass
        write_path_to_file(path, self.traj_write_path)


class SamplingCluster(UmbrellaSampling):
    def __init__(
        self,
        simulation_parameter: SimulationParameters,
        system_info: SystemInfo,
        traj_write_path: str,
        conda_environment: str,
        mail: str = None,
        restrain_backbone: bool = False,
        log_prefix: str = "umbrella_simulation",
        gpu: str = 1,
        sge_working_dir: str = None,
    ) -> None:
        """
        This class holds all information for running your umbrella simulation on the hydra cluster. it works entirely differnt than the UmbrellaSampling class.
        It first writes bash scirpts which it then submits to the submission system.

        At the moment it is not possible to run equilibration and production in one go. After the equilibration has finished, you will have to run the submit_production.sh script generated to submit all the
        jobs for the production run.
    
        Args:
            simulation_parameter (SimulationParameters): simulation_property object.
            path (List[unit.Quantity]): path for the ligand to walk through.
            openmm_system (mm.openmm.System): openmm system of your simulation.
            info (SystemInfo): simulation system object.
            traj_write_path (str): output directory where the trajectories will be written to.
            conda_environment (str): name of the conda environment where this package and all its dependencies are installed.
            mail (str, optional): [description]. if given, a mail will be sent to this adress if a production run has finished.
            log_prefix (str, optional): [description]. give if you want a certain path for your log file.
            gpu (str, optional): how much cpu cores to use. on hydra choose 1. Defaults to 1.
            sge_working_dir (str, optional): the working dir from which you are runnnig this package. Defaults to None.
        """
        super().__init__(
            simulation_parameters=simulation_parameter,
            system_info=system_info,
            traj_write_path=traj_write_path,
            restrain_protein_backbone=restrain_backbone,
        )
        self.hydra_working_dir: str = (
            sge_working_dir if sge_working_dir else os.getcwd()
        )
        self.hydra_working_dir.rstrip("/")
        self.mail: str = mail
        self.log: str = log_prefix.rstrip(".log")
        self.gpu: int = gpu
        self.conda_environment: str = conda_environment
        self.serialized_system_file: str = (
            self.hydra_working_dir + "/serialized_sys.xml"
        )
        self.serialized_state_file: str = (
            self.hydra_working_dir + "/serialized_state.rst"
        )
        self.commands: List[str] = []
        self.simulation_output: List[str] = []
        self.write_scripts = self.write_sge_scripts


    def write_sge_scripts(self, path: unit.Quantity) -> str:
        """
        Writes shell script which is then submitted to a sun grid engine cluster queue.

        Args:
            path: Dissociation pathway generated with this tool.

        Returns:
            str: the path where the file is written to.
        """
        for window, position in enumerate(path):
            script_path = f"{self.hydra_working_dir}/run_umbrella_window_{window}.sh"
            c = "#$ -S /bin/bash\n#$ -m e\n"
            c += "#$ -j y\n"
            c += "#$ -cwd\n"
            c += "#$ -p -1000\n"
            if self.gpu:
                c += f"#$ -l gpu={self.gpu}\n"
            if self.log:
                c += f"#$ -o {self.log}_{window}.log\n\n"
            if self.mail:
                c += f"#$ -M {self.mail}\n"
                c += "#$ -pe smp 1\n"
            c += "hostname\n"
            c += f"conda activate {self.conda_environment}\n"
            c += f"python {os.path.abspath(os.path.dirname(__file__)+'/../scripts/worker_script_cluster.py')} "

            pos = f"-x {position.x} " f"-y {position.y} " f"-z {position.z}"
            c += f" -t {self.simulation_parameters.temperature.value_in_unit(unit=unit.kelvin)}"
            c += f" -dt {self.simulation_parameters.time_step.value_in_unit(unit=unit.femtosecond)}"
            c += f" -fric {self.simulation_parameters.friction_coefficient.value_in_unit(unit=unit.picosecond**-1)}"
            c += (
                f" -psf {self.system_info.psf_file} -crd {self.system_info.crd_file} -sys {self.serialized_system_file} -state {self.serialized_state_file}"
                f" {pos} -to {self.traj_write_path} -np {self.simulation_parameters.n_production_steps} -ln {self.system_info.ligand_name}"
                f" -ne {self.simulation_parameters.n_equilibration_steps} -nw {window} -io {self.simulation_parameters.write_out_frequency}"
            )
            logger.info(f"{script_path} written.")

            with open(script_path, "w") as f:
                f.write(c)

            self.commands.append(f"qsub {script_path}")
        return self.commands


    def write_production_starter(self, commands: List[str]) -> str:
        """
        Writes a bash file, that submits all production jobs.

        Args:
            commands (List[str]): list of starting commands

        Returns:
            str: path to file
        """
        with open(f"{self.hydra_working_dir}/submit_production.sh", "w") as f:
            f.write("#!/bin/bash\n")
            for i in commands:
                f.write(f"{i}\n")
        return f"{self.hydra_working_dir}/submit_production.sh"

    def run_equilibration(
        self,
        use_membrane_barostat: bool = False,
        nonbonded_method: app.forcefield = app.PME,
        nonbonded_cutoff: unit.Quantity = 1.2 * unit.nanometer,
        switch_distance: unit.Quantity = 1 * unit.nanometer,
        rigid_water: bool = True,
        constraints: app.forcefield = app.HBonds,
    ) -> Tuple[mm.State, str]:
        """[summary]
        Runs the equilibration on a sun grid engine cluster.

        Args:
            use_membrane_barostat (bool, optional): Wheter to use a membrane or an isotropic barostat. False means you are deploying the isotropic barostat. Defaults to False.
            nonbonded_method (app.forcefield, optional): which nonbonded method to use. Specify as an openmm.app object. Defaults to app.PME.
            nonbonded_cutoff (unit.Quantity, optional): which nonbonded cutoff to use. Defaults to 1.2*unit.nanometer.
            switch_distance (unit.Quantity, optional): Switch distance for the nonbonded cutoff. Defaults to 1*unit.nanometer.
            rigid_water (bool, optional): Wheter to use rigid water in the simulation. Defaults to True.
            constraints (app.forcefield, optional): Constraints you want to use in the Simulation. Defaults to app.HBonds.
        
        Returns:
            Tuple[mm.State, str]: [description]
        """
        state = super().run_equilibration(
            use_membrane_barostat=use_membrane_barostat,
            nonbonded_method=nonbonded_method,
            nonbonded_cutoff=nonbonded_cutoff,
            switch_distance=switch_distance,
            rigid_water=rigid_water,
            constraints=constraints,
        )

        path = serialize_state(state=state, path=self.serialized_state_file)
        return state, path

    def run_production(
        self,
        path: unit.Quantity,
        state: mm.State,
        nonbonded_method: app.forcefield = app.PME,
        nonbonded_cutoff: unit.Quantity = 1.2 * unit.nanometer,
        switch_distance: unit.Quantity = 1 * unit.nanometer,
        rigid_water: bool = True,
        constraints: app.forcefield = app.HBonds,
    ) -> List[str]:
        """
        This will not run the jobs but create everything needed for the Umbrella sampling to run. 
        to submit the actualy job, run the script that is return by this function.

        Args:        
            path (unit.Quantity): Path generated along wich the Umbrella Sampling is Conducted.
            state (mm.State): State retrieved from the Equilibration. 
            nonbonded_method (app.forcefield, optional): which nonbonded method to use. Specify as an openmm.app object. Defaults to app.PME.
            nonbonded_cutoff (unit.Quantity, optional): which nonbonded cutoff to use. Defaults to 1.2*unit.nanometer.
            switch_distance (unit.Quantity, optional): Switch distance for the nonbonded cutoff. Defaults to 1*unit.nanometer.
            rigid_water (bool, optional): Wheter to use rigid water in the simulation. Defaults to True.
            constraints (app.forcefield, optional): Constraints you want to use in the Simulation. Defaults to app.HBonds.

        Returns:
            str: Path to the bash script that submits the production jobs for the umbrella sampling.
        """

        try:
            write_path_to_file(path, self.traj_write_path)
            if not self.system_info.psf_object.boxLengths:
                gen_pbc_box(
                    psf=self.system_info.psf_object,
                    pos=self.system_info.crd_object.positions,
                )
            self.openmm_system = create_openmm_system(
                system_info=self.system_info,
                simulation_parameters=self.simulation_parameters,
                ligand_restraint=True,
                path=path,
                bb_restraints=self.bb_restrains,
                nonbonded_cutoff=nonbonded_cutoff,
                nonbonded_method=nonbonded_method,
                switch_distance=switch_distance,
                constraints=constraints,
                rigid_water=rigid_water,
                positions=state.getPositions(),
            )
            self.serialized_system_file = serialize_system(
                self.openmm_system, self.serialized_system_file
            )
            self.commands = self.write_sge_scripts(path=path)
            self.write_production_starter(commands=self.commands)

        except FileNotFoundError:
            raise FileNotFoundError(
                "Oops, something went wrong. Make sure you are logged in on the cluster and all the paths you specified are in acceptance with the best practice manual."
            )
        return self.write_production_starter(commands=self.commands)
